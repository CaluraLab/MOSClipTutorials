---
title: "MOSClip Two-Class Analysis on TCGA ovarian cancer patients"
output: html_document
---

## Prepare data for MOSClip analysis

Now we are almost ready to run a two-class analysis with `MOSClip`!
First of all, we can load the necessary libraries and the [pre-processed ovarian cancer datasets](https://caluralab.github.io/MOSClipTutorials/Rmd/downloadTCGA/TCGA-OV-pre-processed.RData) 
that we downloaded from TCGA in the 
[previous tutorials](https://caluralab.github.io/MOSClipTutorials/formatTCGAdatasets.html).
We also set a seed, in order to have reproducible results in case of future repetition of this analysis,
and we create a [directory](https://github.com/CaluraLab/MOSClipTutorials/tree/main/Rmd/MOSresults/twoClass) 
where we will save all the results generated by this tutorial.

```{r message=FALSE}
library(org.Hs.eg.db)
library(EDASeq)
library(graphite)
library(MOSClip)
library(kableExtra)


load("downloadTCGA/TCGA-OV-pre-processed.RData")

set.seed(1234)

dirname <- "MOSresults/twoClass/"
if (!dir.exists(dirname)){
    dir.create(dirname)
}
```

We need to prepare data in order to run `MOSClip`. 
The first step is to modify all the multi-omic matrices assigning the type of gene identifier used. 
Since we’ll be using the `graphite` package to download pathways and their graphical structures, 
gene names across all omics need to be compatible with `graphite`.
For this analysis, we’ll use Entrez Gene IDs. Thus, each gene ID in our data must be 
prefixed with “ENTREZID:” for compatibility.

```{r}
expression <- expAvg
row.names(expression) <- paste0("ENTREZID:", row.names(expression))
mutation <- ov.mutations$data
row.names(mutation) <- paste0("ENTREZID:", row.names(mutation))
names(metClustValues$eMap) <- paste0("ENTREZID:", row.names(metClustValues$eMap))
row.names(ov.cnv) <- paste0("ENTREZID:", row.names(ov.cnv))
```

Moving to patient selection, we keep only patients whose class annotation 
is available and their intersection with available patients across the 4 omics.
Finally, our class annotation data frame is filtered to keep only the selected patients.

```{r}
# select common patients
patients <- row.names(classes)
patients <- intersect(patients, colnames(expression))
patients <- intersect(patients, colnames(metClustValues$MET_Cancer_Clustered))
patients <- intersect(patients, colnames(mutation))
patients <- intersect(patients, colnames(ov.cnv))

classAnnot <- classes[patients, , drop=FALSE]

table(classAnnot)
```

At this point, we need to extract selected patients for each multi-omic matrix. 
After patient selection, we can normalize (upper quartile normalization from `EDASeq` package) 
and log-transform expression data.

```{r}
# normalize expression data
expression <- expression[, patients, drop = FALSE]
keep = apply(expression >= 100, 1, any)
expNorm <- betweenLaneNormalization(expression[keep, , drop = FALSE], which = "upper")
pseudoExpNorm <- log2(expNorm + 1)

methylation <- metClustValues
methylation$MET_Cancer_Clustered <- methylation$MET_Cancer_Clustered[, patients, drop = FALSE]

mutation <- mutation[, patients, drop = FALSE]
cnv <- ov.cnv[, patients, drop = FALSE]
```

We are now ready to generate an object of class `Omics` using the function `makeOmics`.
This object is required to run each type of `MOSClip` analysis. 
It is based on a `MultiAssayExperiment` object, containing an `ExperimentList` with matrices for each omic 
(we suggest to use standard names for each experiment as shown in this example).
`colData` in this case will contain class annotation for patients. Additionally, specific slots 
for `MOSClip` analysis exist, including `modelInfo`, where the user must specify 
the desired method for data reduction for each omic, and `specificArgs`, with specific
parameters to be used by reduction functions. 
Both these slots must have the same dimension as `ExperimentList`.

The list of available methods for data dimensionality reduction can be easily retrieved 
with `availableOmicsMethods()` function.

```{r}
multiOmics <- makeOmics(experiments = list(exp = pseudoExpNorm, 
                                           met = methylation$MET_Cancer_Clustered, 
                                           mut = mutation, 
                                           cnv = as.matrix(cnv)), 
                        colData = classAnnot,
    modelInfo = c("summarizeWithPca", "summarizeInCluster", 
    "summarizeToNumberOfEvents", "summarizeToNumberOfDirectionalEvents"), 
    specificArgs = list(pcaArgs = list(name = "exp", shrink = "FALSE", method = "sparse", maxPCs = 3),
                        clusterArgs = list(name = "met", dict = methylation$eMap, max_cluster_number = 3), 
                        countEvent = list(name = "mut", min_prop = 0.05), 
                        cnvAgv = list(name = "cnv", min_prop = 0.05)))
```

### Download Reactome pathways

To run a `MOSClip` analysis we also need a list of pathways that we want to test,
as well as their graphical structures if we want to exploit the topological method
implemented in the package. 

We decide to use pathways collected in Reactome database. They can be downloaded 
using `graphite` that is also able to convert gene identifiers (here we use 
Entrez Gene ID). 
Since this download and conversion process can take several minutes, we will save the 
[resulting PathwayList object](https://caluralab.github.io/MOSClipTutorials/Rmd/downloadTCGA/reactome-entrez-2024-05-27.RData) 
for easy access in future analyses.

```{r}
if (file.exists("downloadTCGA/reactome-entrez-2024-05-27.RData")) {
  load("downloadTCGA/reactome-entrez-2024-05-27.RData")
} else {
  reactome <- pathways("hsapiens", "reactome")
  reactome <- convertIdentifiers(reactome, "entrez")
  file = paste0("downloadTCGA", "/reactome-entrez-", as.character(Sys.Date()), ".RData")
  save(reactome, file = file)
}
```

To keep analyses efficient and avoid redundancy, we select Reactome pathways 
based on their number of nodes, considering only those nodes that are present at least
in the expression matrix. We prepare two distinct `PathwayList` objects:

* A smaller list with pathways containing between 20 and 100 nodes.
* A larger list with pathways containing between 10 and 700 nodes.

```{r}
nodesLength <- sapply(reactome, function(g) {length(intersect(graphite::nodes(g), 
                                                              row.names(pseudoExpNorm)))})
reactSmall <- reactome[nodesLength >= 20 & nodesLength <= 100]
reactHuge <- reactome[nodesLength >= 10 & nodesLength <= 700]
```

### Prepare class annotations

We define the patient groups to compare, using the subtypes established for 
TCGA ovarian cancer patients. 
For this tutorial, we’ll focus on a multi-omic comparison between 
immunoreactive and mesenchymal subtypes, which should provide interesting insights.
The user can decide which subtypes to compare.

We then filter accordingly our class annotation data frame and `multiOmics` object.

```{r}
class1 <- "Immunoreactive"
class2 <- "Mesenchymal"

classAnnotation <- classAnnot[classAnnot$classes %in% c(class1, class2), , drop=FALSE]
multiOmics <- multiOmics[,row.names(classAnnotation)]
```

Now we are ready for `MOSClip` two-class analysis.

## Two-class analysis on modules

We start from the analysis on modules using the function `multiOmicsTwoClassModuleTest`.
Required inputs are an `Omics` object, a graph, and a class annotation data frame.
Patients in class annotation should have the same order as in `colData`.
Reactome database is built with a hierarchical organization: different
pathways represent the same process with more or less details, going from very
specific and small pathways to very large and general ones.
To avoid redundant results, we choose to focus on a subset of pathways, specifically those having
between 20 and 100 nodes (`reactSmall` list); this way, we aim to limit the overlap
in gene testing.

This step will take some minutes. For this reason, we'll save the [final output](https://caluralab.github.io/MOSClipTutorials/Rmd/MOSresults/twoClass/twoClassM.rds) 
in the directory "MOSresults", and in case of future analyses we'll load it from there.

```{r message=FALSE, warning=FALSE}
if (file.exists(paste0(dirname, "twoClassM.rds"))){
  twoClassM <- readRDS(paste0(dirname, "twoClassM.rds"))
} else { 
    twoClassM <- lapply(reactSmall, function(g) {
        res <- multiOmicsTwoClassModuleTest(multiOmics, g, classAnnotation, 
                                            useTheseGenes = row.names(pseudoExpNorm))
        res
    })
    saveRDS(twoClassM, file = paste0(dirname, "twoClassM.rds"))
}
```

The result is a list of `MultiOmicsModules` objects. This list can be used within 
the function `multiPathwayModuleReport` to return a tabular summary of modules, sorted
by p-values. Besides the p-value for each module, p-values for tested covariates are shown. 
The user can specify which covariates to visualize first in the data frame columns, 
giving the omic names to `priority_to` argument.

```{r}
moduleSummary <- multiPathwayModuleReport(twoClassM, 
                                          priority_to = c("exp", "met", "cnv"))
```

```{r echo=FALSE}
kable(moduleSummary[1:100,-1]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "600px")
```

### Permutations

So far, we have identified some modules that are significant. We can test the
robustness of our findings using a resampling procedure. With this strategy, we
can repeat the two-class test on a subset of patients, removing 3 random patients at each iteration.
Modules are prioritized if they show a resampling success score greater than 80.

We will run the analysis on a subset of pathways, considering only those pathways whose
modules were found significant. 

Since this step will take much time,  [results](https://caluralab.github.io/MOSClipTutorials/Rmd/MOSresults/twoClass/permsM.RData) 
are saved.

```{r warning=FALSE}
useThisPathways <- unique(moduleSummary$pathway[moduleSummary$pvalue <= 0.05])
sModule <- moduleSummary[moduleSummary$pathway %in% useThisPathways, , drop = TRUE]

if (file.exists(paste0(dirname, "permsM.RData"))){
    load(paste0(dirname, "permsM.RData"))
}else{
    perms <- resamplingModulesTwoClass(fullMultiOmics = multiOmics, 
                                       classAnnotation, reactSmall, nperm = 100, 
                                       nPatients = 3, pathwaySubset = useThisPathways, 
                                       genesToConsider = row.names(pseudoExpNorm))
    save(perms, file = paste0(dirname, "permsM.RData"))
}
```

The function `selectStablePathwaysModules` will retrieve the tabular summary of the results
for those pathway modules whose success score is greater than 80. It will also print 
a dotplot showing the resampling success of modules based on their significance level.
The resampling success count can be retrieved with `getPathwaysModulesSuccess` and
counts can be appended as a new column to the tabular summary of module results with `addResamplingCounts`.

```{r}
stableModulesSummary <- selectStablePathwaysModules(perms = perms, moduleSummary = sModule, success = 80)
resamplingSuccessCount <- getPathwaysModulesSuccess(perms = perms, moduleSummary = sModule)
moduleSummary <- addResamplingCounts(moduleSummary, resamplingSuccessCount)
```

### Plots

The tabular results can also be visualized in a plot, that helps comparing the 
contribution of each covariate to the significance of a module. This is done with 
`plotModuleReport`. The user must provide the `MultiOmicsModules` object for the pathway of interest;
for this tutorial, we choose to focus on the pathway "Syndecan interactions".

```{r}
plotModuleReport(twoClassM[["Syndecan interactions"]],
                 MOcolors = c(exp = "red", met = "green", cnv = "yellow"),
                 priority_to = c("exp", "met"))
```

The most significant module for this pathway is the third one.
The omics that are mainly involved are expression and methylation,
as we can see from the p-values of the model covariates (expPC1, expPC2, met3k2).

We can have a look at the structure of the pathway graph and the module position in the pathway.
The genes of module 3 are colored in red and and the contribution of each omic 
inside the module is highlighted with different colors.

```{r message=FALSE}
plotModuleInGraph(twoClassM[["Syndecan interactions"]], reactSmall, 3,
                  paletteNames = c(exp="red", met="green", cnv="yellow"))
```

Using a heatmap, we can visualize the profiles of predictive genes, the top 3 genes for each omic.
Above the heatmap, we can also show patient additional annotations, in this case their class annotation, 
and the summarized value of each covariate for each patient.

```{r message=FALSE}
plotModuleHeat(twoClassM[["Syndecan interactions"]], 3, 
               additionalAnnotations = classAnnotation, 
               additionalPaletteNames = list(classes="violet"))
```

In second instance, we can ask if two or more omics are significant in the same module 
simultaneously and if this omic interaction is more frequent than those expected by chance. 
To perform this test, we use the `runSupertest` function. 
We plot only modules that are significant and have a success score greater than 80.
A circle plot is returned with the frequency of all significant omic combinations and their significance levels,
represented by the height and the color of the outer layer.

```{r fig.height=6, fig.width=7}
runSupertest(moduleSummary, pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80,
             excludeColumns = c("pathway", "module", "resamplingCount"))
```

As you can see, the combination of cnv and expression is significant, as well as 
the combination of expression and methylation. These combinations of omics co-regulate
the same pathway modules more often than what expected by chance.

Finally, with `plotFrequencies` it is possible to show the frequency distribution of
pathways aggregated into macro-categories, generated using Reactome hierarchical structure,
separately for each omic combination. This plot suggests biological processes that may 
be impacted by the omics and their cross-talk. 

```{r fig.height=7}
pathHierarchyGraph <-  igraph::graph_from_data_frame(d = downloadPathwayRelationFromReactome(), directed = TRUE)

omicsClasses2pathways <- computeOmicsIntersections(moduleSummary, 
                                                   pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80, 
                                                   excludeColumns = c("pathway", "module", "resamplingCount"))
omicsClasses2pathways <- lapply(omicsClasses2pathways, stripModulesFromPathways)
omicsClasses2fathers <- lapply(omicsClasses2pathways, annotePathwayToFather, 
                               graphiteDB = reactome, hierarchy = pathHierarchyGraph)

MOMfreqDataframe <- computeFreqs(omicsClasses2fathers)

combiClass <- grep(";", MOMfreqDataframe$class)
MOMfreqDataframe.multi <- MOMfreqDataframe[combiClass, , drop = FALSE]

plotFrequencies(MOMfreqDataframe.multi, minSize = 6, maxSize = 9, width = 10, lineSize = 1)
```




## Two-class analysis on pathways

The same analysis can be run on pathways rather than modules. In this case, since 
we are using pathway graph structures, we suggest to adopt the topological method 
for PCA, as implemented in `MOSClip`, as well as a shrinkage approach. To do this,
we change parameters for PCA in the `secificArgs` slot of our `Omics` object.

```{r}
multiOmics@specificArgs$pcaArgs$shrink=TRUE
multiOmics@specificArgs$pcaArgs$method="topological"
```

We are now ready to run the two-class analysis on pathways with the function
`multiOmicsTwoClassPathwayTest`. The required input are the same shown for modules.
In this case, we choose to test a greater amount of pathways (`reactHuge` list). 
Again, since this may take some minutes, we save the [results](https://caluralab.github.io/MOSClipTutorials/Rmd/MOSresults/twoClass/twoClassP.rds) 
for future usage.

```{r warning=FALSE}
if (file.exists(paste0(dirname, "twoClassP.rds"))){
  twoClassP <- readRDS(paste0(dirname, "twoClassP.rds"))
} else {
  twoClassP <- lapply(reactHuge, function(g) {
    res <- multiOmicsTwoClassPathwayTest(multiOmics, g, classAnnotation, 
                                         useTheseGenes = row.names(pseudoExpNorm))
    res
  })
  saveRDS(twoClassP, file = paste0(dirname, "twoClassP.rds"))
 }
```

The summary of the results is obtained with `multiPathwayReport`.

```{r}
pathwaySummary <- multiPathwayReport(twoClassP)
```

```{r echo=FALSE}
kable(pathwaySummary[1:100,]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "600px")
```

### Permutations

Again, we can repeat the test on significant pathways applying a resampling strategy
for a total of 100 iteration and we save the [results](https://caluralab.github.io/MOSClipTutorials/Rmd/MOSresults/twoClass/permsP.RData).
We can see from the dotplot that the vast majority of pathways is found significant
in more than 80 iterations.
We can extract stable pathways and add a column with the resampling success count
on the pathway summary.

```{r warning=FALSE}
useThisPathways <- unique(row.names(pathwaySummary)[pathwaySummary$pvalue <= 0.05])
sPathway <- pathwaySummary[row.names(pathwaySummary) %in% useThisPathways, , drop = TRUE]

if (file.exists(paste0(dirname, "permsP.RData"))){
    load(paste0(dirname, "permsP.RData"))
} else{
    perms <- resamplingPathwayTwoClass(fullMultiOmics = multiOmics, 
                                       classAnnotation, reactHuge, 
                                       nperm = 100, nPatients = 3,
                                       pathwaySubset = useThisPathways, 
                                       genesToConsider = row.names(pseudoExpNorm))
    save(perms, file = paste0(dirname, "permsP.RData"))
}


stablePathwaysSummary <- selectStablePathwaysModules(perms = perms, moduleSummary = sPathway, success = 80)
resamplingSuccessCount <- getPathwaysModulesSuccess(perms = perms, moduleSummary = sPathway)
pathwaySummary <- addResamplingCounts(pathwaySummary, resamplingSuccessCount)
```

### Plots

With the function `plotMultiPathwayReport` we can plot the test summary for a subset
of pathways.

```{r}
plotMultiPathwayReport(twoClassP[1:20],
                       MOcolors = c(exp = "red", mut = "blue", 
                                    cnv = "yellow", met = "green"),
                       priority_to = c("exp", "met"),
                       fontsize = 5)
```

We select "Adherens junctions interactions" pathway and plot the heatmap of prioritized genes
for each omic. 

```{r message=FALSE}
plotPathwayHeat(twoClassP[["Adherens junctions interactions"]], 
                additionalAnnotations = classAnnotation,
                additionalPaletteNames = list(classes = "violet"))
```

As found for module tests, the combination of expression and CNV, as well the combination 
of expression and methylation, co-regulate pathways more often than what expected by chance.

```{r fig.height=6, fig.width=7}
runSupertest(pathwaySummary, 
             pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80,
             excludeColumns = "resamplingCount")
```

The frequency plot shows that the combination of CNV and expression mainly affects 
signaling pathways, disease and immune system; the same happens with the combination
of expression and methylation, with the addition in this case of gene expression
macrocategory.

```{r fig.height=7}
omicsClasses2pathways <- computeOmicsIntersections(pathwaySummary, 
                                                   pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80,
                                                   excludeColumns = "resamplingCount")
omicsClasses2fathers <- lapply(omicsClasses2pathways, annotePathwayToFather, 
                               graphiteDB = reactome, hierarchy = pathHierarchyGraph)
freqDataframe <- computeFreqs(omicsClasses2fathers)

combiClass <- grep(";", freqDataframe$class)
freqDataframe.multi <- freqDataframe[combiClass, , drop = FALSE]

plotFrequencies(freqDataframe.multi, minSize = 6, maxSize = 9, width = 10, lineSize = 1)
```


## Data availability

- The list of Reactome pathways and the pre-processed datasets used in this tutorial 
are available [here](https://github.com/CaluraLab/MOSClipTutorials/tree/main/Rmd/downloadTCGA).

- Results obtained by running this tutorial are available 
[here](https://github.com/CaluraLab/MOSClipTutorials/tree/main/Rmd/MOSresults/twoClass).



```{r}
sessionInfo()
```

