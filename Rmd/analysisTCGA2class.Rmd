---
title: "MOSClip Two-Class Analysis on TCGA ovarian cancer patients"
output: html_document
---

## Prepare data for MOSClip analysis

Now we are almost ready to run a two-class analysis with MOSClip!
First of all, we can load necessary libraries and the [pre-processed ovarian cancer datasets](https://github.com/CaluraLab/MOSClipTutorials/blob/main/Rmd/downloadTCGA/TCGA-OV-pre-processed.RData) 
that we downloaded from TCGA in the 
[previous tutorials](https://caluralab.github.io/MOSClipTutorials/formatTCGAdatasets.html).
We will also set a seed, in order to have reproducible results in case of future repetition of the analysis,
and we will create a [directory](https://github.com/CaluraLab/MOSClipTutorials/tree/main/Rmd/MOSresults/twoClass) 
where we will save all the results generated by this tutorial.

```{r message=FALSE}
library(org.Hs.eg.db)
library(EDASeq)
library(graphite)
library(MOSClip)
library(kableExtra)


load("downloadTCGA/TCGA-OV-pre-processed.RData")

set.seed(1234)

dirname <- "MOSresults/twoClass/"
if (!dir.exists(dirname)){
    dir.create(dirname)
}
```

We need to prepare data in order to run MOSClip. 
The first step is to modify all the multi-omic matrices assigning the type of gene identifier. 
Since we will use `graphite` to download a list of pathways and their graphical structure, 
we need to format gene names for each omic in order to be compatible with `graphite`. 
Here, we will work with Entrez Gene ID, thus we have to indicate with the prefix tag â€œENTREZID:" each gene.

```{r}
expression <- expAvg
row.names(expression) <- paste0("ENTREZID:", row.names(expression))
mutation <- ov.mutations$data
row.names(mutation) <- paste0("ENTREZID:", row.names(mutation))
names(metClustValues$eMap) <- paste0("ENTREZID:", row.names(metClustValues$eMap))
row.names(ov.cnv) <- paste0("ENTREZID:", row.names(ov.cnv))
```

Moving to patient selection, we will keep only patients whose class annotation 
is available and their intersection with available patients across the 4 omics.
Finally, our class annotation dataframe will be filtered to keep only selected patients.

```{r}
# select common patients
patients <- row.names(classes)
patients <- intersect(patients, colnames(expression))
patients <- intersect(patients, colnames(metClustValues$MET_Cancer_Clustered))
patients <- intersect(patients, colnames(mutation))
patients <- intersect(patients, colnames(ov.cnv))

classAnnot <- classes[patients, , drop=FALSE]

table(classAnnot)
```

At this point, we need to extract selected patients for each multi-omic matrix. 
After patient selection, we can normalize (upper quartile normalization from `EDASeq` package) 
and log-transform expression data.

```{r}
# normalize expression data
expression <- expression[, patients, drop = FALSE]
keep = apply(expression >= 100, 1, any)
expNorm <- betweenLaneNormalization(expression[keep, , drop = FALSE], which = "upper")
pseudoExpNorm <- log2(expNorm + 1)

methylation <- metClustValues
methylation$MET_Cancer_Clustered <- methylation$MET_Cancer_Clustered[, patients, drop = FALSE]

mutation <- mutation[, patients, drop = FALSE]
cnv <- ov.cnv[, patients, drop = FALSE]
```

We are now ready to generate an object of class `Omics` using MOSClip function `makeOmics`.
This object is required to run each type of `MOSClip` analysis. 
It is based on `MultiAssayExperiment` object, containing an `ExperimentList` with matrices for each omic 
(we suggest to use standard names for each experiment as shown in this example).
`colData` in this case will contain class annotation for patients. Additionally, specific slots 
for `MOSClip` analysis exist, including `modelInfo`, where the user must specify 
the desired method for data reduction for each omic, and `specificArgs`, with specific
parameters to be used by reduction functions. 
Both these slots must have the same dimension as `ExperimentList`.

The list of available methods for data dimensionality reduction is easily visualized 
with `availableOmicsMethods()`.

```{r}
multiOmics <- makeOmics(experiments = list(exp = pseudoExpNorm, 
                                           met = methylation$MET_Cancer_Clustered, 
                                           mut = mutation, 
                                           cnv = as.matrix(cnv)), 
                        colData = classAnnot,
    modelInfo = c("summarizeWithPca", "summarizeInCluster", 
    "summarizeToNumberOfEvents", "summarizeToNumberOfDirectionalEvents"), 
    specificArgs = list(pcaArgs = list(name = "exp", shrink = "FALSE", method = "sparse", maxPCs = 3),
                        clusterArgs = list(name = "met", dict = methylation$eMap, max_cluster_number = 3), 
                        countEvent = list(name = "mut", min_prop = 0.05), 
                        cnvAgv = list(name = "cnv", min_prop = 0.05)))
```

### Download Reactome pathways

To run a `MOSClip` analysis we also need the list of pathways that we want to test,
as well as their graphical structure if we want to exploit the topological analysis. 

We decide to use pathways collected in Reactome database. They can be downloaded 
using `graphite` that is also able to convert gene identifiers (here we will use 
Entrez Gene ID). This process may take some minutes, for this reason we will save
the [final `PathwayList` object](https://github.com/CaluraLab/MOSClipTutorials/blob/main/Rmd/downloadTCGA/reactome-entrez-2024-05-27.RData), 
ready to be used in future analyses.

```{r}
if (file.exists("downloadTCGA/reactome-entrez-2024-05-27.RData")) {
  load("downloadTCGA/reactome-entrez-2024-05-27.RData")
} else {
  reactome <- pathways("hsapiens", "reactome")
  reactome <- convertIdentifiers(reactome, "entrez")
  file = paste0("downloadTCGA", "/reactome-entrez-", as.character(Sys.Date()), ".RData")
  save(reactome, file = file)
}
```

To avoid redundant and too heavy analyses, we select Reactome pathways based on their 
number of nodes, considering only nodes that are present at least in the expression matrix.
We prepare two distinct `PathwayList` objects: 

* one containing pathways with more than 20 and less than 100 nodes,  
* a larger one with pathways having more than 10 and less than 700 nodes. 

```{r}
nodesLength <- sapply(reactome, function(g) {length(intersect(graphite::nodes(g), 
                                                              row.names(pseudoExpNorm)))})
reactSmall <- reactome[nodesLength >= 20 & nodesLength <= 100]
reactHuge <- reactome[nodesLength >= 10 & nodesLength <= 700]
```

### Prepare class annotations

We define the classes that we want to compare. Here we are using the subtypes 
defined for TCGA ovarian cancer patients. For the purpose of this tutorial, it could be interesting to compare
on a multi-omic level immunoreactive patients with mesenchymal patients. The user 
can decide which subtypes to compare.

We can filter accordingly our class annotation data frame and `multiOmics` object.

```{r}
class1 <- "Immunoreactive"
class2 <- "Mesenchymal"

classAnnotation <- classAnnot[classAnnot$classes %in% c(class1, class2), , drop=FALSE]
multiOmics <- multiOmics[,row.names(classAnnotation)]
```

Now we are ready for MOSClip two-class analysis.

## Two-class analysis on modules

We start from the analysis on modules using the function `multiOmicsTwoClassModuleTest`.
Required inputs are an `Omics` object, a graph, and a class annotation data frame.
Patients in class annotation should have the same order as in `colData`.
Reactome database is built with a hierarchical organization: different
pathways represent the same process with more or less details, going from very
specific and small pathways to very large and general ones.
To avoid redundant results, we choose focus on a subset of pathways, specifically those having
between 20 and 100 nodes (`reactSmall` list); this way, we aim to limit the overlap
in gene testing.

This step will take some minutes. For this reason, we will save the [final output](https://github.com/CaluraLab/MOSClipTutorials/blob/main/Rmd/MOSresults/twoClass/twoClassM.rds) 
in the directory "MOSresults", and in case of future analyses we will load it from there.

```{r message=FALSE, warning=FALSE}
if (file.exists(paste0(dirname, "twoClassM.rds"))){
  twoClassM <- readRDS(paste0(dirname, "twoClassM.rds"))
} else { 
    twoClassM <- lapply(reactSmall, function(g) {
        res <- multiOmicsTwoClassModuleTest(multiOmics, g, classAnnotation, 
                                            useTheseGenes = row.names(pseudoExpNorm))
        res
    })
    saveRDS(twoClassM, file = paste0(dirname, "twoClassM.rds"))
}
```

The result is a list of `MultiOmicsModules` objects. This list can be used within 
the function `multiPathwayModuleReport` to return a tabular summary of modules, sorted
by p-values. Besides the p-value for each module, p-values for tested covariates are shown. 
The user can specify which covariates to visualize first in the data frame columns, 
giving the omic names to `priority_to` argument.

```{r}
moduleSummary <- multiPathwayModuleReport(twoClassM, 
                                          priority_to = c("exp", "met", "cnv"))
```

```{r echo=FALSE}
kable(moduleSummary[1:100,-1]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "600px")
```

### Permutations

So far, we have identified some modules that are significant. We can test the
robustness of our findings using a resampling procedure. With this strategy, we
can repeat the two-class test on a subset of patients, removing 3 random patients at each iteration.
Modules are prioritized if they show a resampling success score greater than 80.

We will run the analysis on a subset of pathways, considering only those pathways whose
modules were found significant. 

Since this step will take much time,  [results](https://github.com/CaluraLab/MOSClipTutorials/blob/main/Rmd/MOSresults/twoClass/permsM.RData) 
are saved.

```{r warning=FALSE}
useThisPathways <- unique(moduleSummary$pathway[moduleSummary$pvalue <= 0.05])
sModule <- moduleSummary[moduleSummary$pathway %in% useThisPathways, , drop = TRUE]

if (file.exists(paste0(dirname, "permsM.RData"))){
    load(paste0(dirname, "permsM.RData"))
}else{
    perms <- resamplingModulesTwoClass(fullMultiOmics = multiOmics, 
                                       classAnnotation, reactSmall, nperm = 100, 
                                       nPatients = 3, pathwaySubset = useThisPathways, 
                                       genesToConsider = row.names(pseudoExpNorm))
    save(perms, file = paste0(dirname, "permsM.RData"))
}
```

The function `selectStablePathwaysModules` will retrieve the tabular summary of the results
for those pathway modules whose success score is greater than 80. It will also print 
a dotplot showing the resampling success of modules based on their significance level.
The resampling success count can be retrieved with `getPathwaysModulesSuccess` and
counts can be appended to the tabular summary of module results with `addResamplingCounts`.

```{r}
stableModulesSummary <- selectStablePathwaysModules(perms = perms, moduleSummary = sModule, success = 80)
resamplingSuccessCount <- getPathwaysModulesSuccess(perms = perms, moduleSummary = sModule)
moduleSummary <- addResamplingCounts(moduleSummary, resamplingSuccessCount)
```

### Plots

The tabular results can also be visualized in a plot, that helps comparing the 
contribution of each covariate to the significance of a module. This is done with 
`plotModuleReport`. The user must provide the `MultiOmicsModules` object for the pathway of interest;
for this tutorial we choose to focus on the pathway "Syndecan interactions".

```{r}
plotModuleReport(twoClassM[["Syndecan interactions"]],
                 MOcolors = c(exp = "red", met = "green", cnv = "yellow"),
                 priority_to = c("exp", "met"))
```

The most significant module for this pathway is the third one.
The omics that are mainly involved are expression and methylation,
as we can see from the p-values of the model covariates (expPC1, expPC2, met3k2).

We can have a look at the structure of the pathway graph and the module position in the pathway.
The genes of module 3 are colored in red and and the contribution of each omic 
inside the module is highlighted with different colors.

```{r message=FALSE}
plotModuleInGraph(twoClassM[["Syndecan interactions"]], reactSmall, 3,
                  paletteNames = c(exp="red", met="green", cnv="yellow"))
```

Using a heatmap, we can visualize the profiles of predictive genes, the top 3 genes for each omic.
Above the heatmap, we can also show patient additional annotations, in this case their class annotation, 
and the summarized value of each covariate for each patient.

```{r message=FALSE}
plotModuleHeat(twoClassM[["Syndecan interactions"]], 3, 
               additionalAnnotations = classAnnotation, 
               additionalPaletteNames = list(classes="violet"))
```

In second instance, we can ask if two or more omics are significant in the same module 
simultaneously and if this omic interaction is more frequent than those expected by chance. 
To perform this test, we use the `runSupertest` function. 
We will plot only modules that are significant and have a success score greater than 80.
A circle plot is returned with the frequency of all significant omic combinations and their significance levels,
represented by the height and the color of the outer layer.

```{r}
runSupertest(moduleSummary, pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80,
             excludeColumns = c("pathway", "module", "resamplingCount"))
```

As you can see, the combination of cnv and expression is significant, as well as 
the combination of expression and methylation. These combinations of omics co-regulate
the same pathway modules more often than what expected by chance.

Finally, with `plotFrequencies` it is possible to show the frequency distribution of
pathways aggregated into macro-categories, using Reactome hierarchical structure,
separately for each omic combination. This plot suggests biological processes that may 
be impacted by the omics and their cross-talk. 

```{r}
pathHierarchyGraph <-  igraph::graph_from_data_frame(d = downloadPathwayRelationFromReactome(), directed = TRUE)

omicsClasses2pathways <- computeOmicsIntersections(moduleSummary, 
                                                   pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80, 
                                                   excludeColumns = c("pathway", "module", "resamplingCount"))
omicsClasses2pathways <- lapply(omicsClasses2pathways, stripModulesFromPathways)
omicsClasses2fathers <- lapply(omicsClasses2pathways, annotePathwayToFather, 
                               graphiteDB = reactome, hierarchy = pathHierarchyGraph)

MOMfreqDataframe <- computeFreqs(omicsClasses2fathers)

combiClass <- grep(";", MOMfreqDataframe$class)
MOMfreqDataframe.multi <- MOMfreqDataframe[combiClass, , drop = FALSE]

plotFrequencies(MOMfreqDataframe.multi, minSize = 6, maxSize = 8, width = 10, lineSize = 1)
```




## Two-class analysis on pathways

The same analysis can be run on pathways rather than modules. In this case, since 
we are using pathway graph structures, we suggest to adopt the topological method 
for PCA, as implemented in `MOSClip`, as well as a shrinkage approach. To do this,
we change parameters for PCA in the `secificArgs` slot of our `Omics` object.

```{r}
multiOmics@specificArgs$pcaArgs$shrink=TRUE
multiOmics@specificArgs$pcaArgs$method="topological"
```

We are now ready to run the two-class analysis on pathways with the function
`multiOmicsTwoClassPathwayTest`. The required input are the same shown for modules.
In this case, we choose to test a greater amount of pathways (`reactHuge` list). 
Again, this may take some minutes, thus, we save the [results](https://github.com/CaluraLab/MOSClipTutorials/blob/main/Rmd/MOSresults/twoClass/twoClassP.rds) 
for future usage.

```{r warning=FALSE}
if (file.exists(paste0(dirname, "twoClassP.rds"))){
  twoClassP <- readRDS(paste0(dirname, "twoClassP.rds"))
} else {
  twoClassP <- lapply(reactHuge, function(g) {
    res <- multiOmicsTwoClassPathwayTest(multiOmics, g, classAnnotation, 
                                         useTheseGenes = row.names(pseudoExpNorm))
    res
  })
  saveRDS(twoClassP, file = paste0(dirname, "twoClassP.rds"))
 }
```

The summary of the results is obtained with `multiPathwayReport`.

```{r}
pathwaySummary <- multiPathwayReport(twoClassP)
```

```{r echo=FALSE}
kable(pathwaySummary[1:100,-1]) %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "600px")
```

### Permutations

Again, we can repeat the test on significant pathways applying a resampling strategy
for a total of 100 iteration and we save the [results](https://github.com/CaluraLab/MOSClipTutorials/blob/main/Rmd/MOSresults/twoClass/permsP.RData).
We can see from the dotplot that the vast majority of pathways is found significant
in more than 80 iterations.
We can extract stable pathways and add a column with the resampling success count
on the pathway summary.

```{r warning=FALSE}
useThisPathways <- unique(row.names(pathwaySummary)[pathwaySummary$pvalue <= 0.05])
sPathway <- pathwaySummary[row.names(pathwaySummary) %in% useThisPathways, , drop = TRUE]

if (file.exists(paste0(dirname, "permsP.RData"))){
    load(paste0(dirname, "permsP.RData"))
} else{
    perms <- resamplingPathwayTwoClass(fullMultiOmics = multiOmics, 
                                       classAnnotation, reactHuge, 
                                       nperm = 100, nPatients = 3,
                                       pathwaySubset = useThisPathways, 
                                       genesToConsider = row.names(pseudoExpNorm))
    save(perms, file = paste0(dirname, "permsP.RData"))
}


stablePathwaysSummary <- selectStablePathwaysModules(perms = perms, moduleSummary = sPathway, success = 80)
resamplingSuccessCount <- getPathwaysModulesSuccess(perms = perms, moduleSummary = sPathway)
pathwaySummary <- addResamplingCounts(pathwaySummary, resamplingSuccessCount)
```

### Plots

With the function `plotMultiPathwayReport` we can plot the test summary for a subset
of pathways.

```{r}
plotMultiPathwayReport(twoClassP[1:20],
                       MOcolors = c(exp = "red", mut = "blue", 
                                    cnv = "yellow", met = "green"),
                       priority_to = c("exp", "met"),
                       fontsize = 5)
```

We select "Adherens junctions interactions" pathway and plot the heatmap of prioritized genes
for each omic. 

```{r message=FALSE}
plotPathwayHeat(twoClassP[["Adherens junctions interactions"]], 
                additionalAnnotations = classAnnotation,
                additionalPaletteNames = list(classes = "violet"))
```

As found for module tests, the combination of expression and CNV, as well the combination 
of expression and methylation, co-regulate pathways more often than what expected by chance.

```{r}
runSupertest(pathwaySummary, 
             pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80,
             excludeColumns = "resamplingCount")
```

The frequency plot shows that the combination of CNV and expression mainly affects 
signaling pathways, disease and immune system; the same happens with the combination
of expression and methylation, with the addition in this case of gene expression
macrocategory.

```{r}
omicsClasses2pathways <- computeOmicsIntersections(pathwaySummary, 
                                                   pvalueThr = 0.05, zscoreThr = 0.05, resampligThr = 80,
                                                   excludeColumns = "resamplingCount")
omicsClasses2fathers <- lapply(omicsClasses2pathways, annotePathwayToFather, 
                               graphiteDB = reactome, hierarchy = pathHierarchyGraph)
freqDataframe <- computeFreqs(omicsClasses2fathers)

combiClass <- grep(";", freqDataframe$class)
freqDataframe.multi <- freqDataframe[combiClass, , drop = FALSE]

plotFrequencies(freqDataframe.multi, minSize = 3, maxSize = 7, width = 9, lineSize = 1)
```


## Data availability

- The list of Reactome pathways and the pre-processed datasets used in this tutorial 
are available [here](https://github.com/CaluraLab/MOSClipTutorials/tree/main/Rmd/downloadTCGA).

- Results obtained by running this tutorial are available 
[here](https://github.com/CaluraLab/MOSClipTutorials/tree/main/Rmd/MOSresults/twoClass).



```{r}
sessionInfo()
```

